<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Gözleme Finder London</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link rel="preconnect" href="https://maps.googleapis.com">
<link rel="preconnect" href="https://places.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=Playfair+Display:ital,wght@0,700;1,400&family=DM+Mono:wght@400;500&family=DM+Sans:wght@300;400;500&display=swap" rel="stylesheet">
<style>
  :root {
    --bg: #f5ede0;
    --ink: #1a1008;
    --terracotta: #c9512a;
    --gold: #d4a017;
    --cream: #fdf6ec;
    --smoke: #e8ddd0;
    --accent: #2a6b5c;
    --places-blue: #1a73e8;
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    background: var(--bg);
    color: var(--ink);
    font-family: 'DM Sans', sans-serif;
    min-height: 100vh;
    overflow-x: hidden;
  }

  body::before {
    content: '';
    position: fixed; inset: 0;
    background-image:
      radial-gradient(circle at 15% 20%, rgba(201,81,42,0.08) 0%, transparent 40%),
      radial-gradient(circle at 85% 70%, rgba(42,107,92,0.08) 0%, transparent 40%);
    pointer-events: none;
    z-index: 0;
  }

  .container {
    max-width: 980px;
    margin: 0 auto;
    padding: 0 24px;
    position: relative;
    z-index: 1;
  }

  /* ── Header ── */
  header { padding: 48px 0 28px; text-align: center; }

  .eyebrow {
    font-family: 'DM Mono', monospace;
    font-size: 11px; letter-spacing: 0.2em; text-transform: uppercase;
    color: var(--terracotta); margin-bottom: 14px;
  }

  h1 {
    font-family: 'Playfair Display', serif;
    font-size: clamp(40px, 7vw, 72px);
    line-height: 0.95; color: var(--ink);
  }
  h1 em { font-style: italic; color: var(--terracotta); }

  .subtitle {
    font-size: 15px; color: #6b5a4a; font-weight: 300;
    margin-top: 16px; max-width: 440px;
    margin-left: auto; margin-right: auto; line-height: 1.6;
  }

  /* ── Divider ── */
  .divider { display: flex; align-items: center; gap: 12px; margin: 24px 0; }
  .divider::before, .divider::after { content: ''; flex: 1; height: 1px; background: linear-gradient(to right, transparent, var(--gold)); }
  .divider::after { background: linear-gradient(to left, transparent, var(--gold)); }
  .divider span { font-size: 16px; }

  /* ── Search ── */
  .search-section {
    background: var(--cream); border: 1px solid var(--smoke); border-radius: 2px;
    padding: 24px 28px; margin-bottom: 28px;
    box-shadow: 6px 6px 0 rgba(201,81,42,0.1);
  }
  .search-label {
    font-family: 'DM Mono', monospace; font-size: 11px; letter-spacing: 0.15em;
    text-transform: uppercase; color: #8a7060; display: block; margin-bottom: 10px;
  }
  .search-row { display: flex; gap: 12px; flex-wrap: wrap; }
  .search-input {
    flex: 1; min-width: 200px; padding: 12px 18px; border: 1.5px solid var(--smoke);
    border-radius: 2px; background: var(--bg); font-family: 'DM Sans', sans-serif;
    font-size: 16px; color: var(--ink); outline: none; transition: border-color 0.2s;
  }
  .search-input:focus { border-color: var(--terracotta); }
  .search-input-wrap { position: relative; flex: 1; min-width: 200px; }
  .search-input-wrap .search-input { width: 100%; min-width: 0; padding-right: 36px; }
  .clear-btn {
    position: absolute; right: 10px; top: 50%; transform: translateY(-50%);
    background: none; border: none; cursor: pointer; color: #b09a88;
    font-size: 16px; line-height: 1; padding: 0 2px;
    display: none; transition: color 0.15s;
  }
  .clear-btn:hover { color: var(--terracotta); }
  .clear-btn.visible { display: block; }
  .search-btn {
    padding: 12px 28px; background: var(--terracotta); color: white; border: none;
    border-radius: 2px; font-family: 'DM Mono', monospace; font-size: 12px;
    letter-spacing: 0.08em; text-transform: uppercase; cursor: pointer;
    transition: all 0.2s; white-space: nowrap;
  }
  .search-btn:hover { background: #b04422; transform: translateY(-1px); box-shadow: 0 4px 12px rgba(201,81,42,0.3); }
  .search-btn:disabled { background: #c4a898; transform: none; box-shadow: none; cursor: not-allowed; }

  /* ── Loading ── */
  .loading { text-align: center; padding: 48px 0; display: none; }
  .loading.active { display: block; }
  .spinner {
    width: 36px; height: 36px; border: 3px solid var(--smoke);
    border-top-color: var(--terracotta); border-radius: 50%;
    animation: spin 0.8s linear infinite; margin: 0 auto 14px;
  }
  @keyframes spin { to { transform: rotate(360deg); } }
  .loading-text { font-family: 'DM Mono', monospace; font-size: 12px; color: #8a7060; letter-spacing: 0.1em; }
  .loading-steps { margin-top: 10px; display: flex; flex-direction: column; gap: 4px; align-items: center; }
  .loading-step { font-family: 'DM Mono', monospace; font-size: 10px; color: #c4a898; letter-spacing: 0.08em; transition: color 0.3s; }
  .loading-step.active { color: var(--terracotta); }
  .loading-step.done   { color: var(--accent); }

  /* ── Error ── */
  .error { display: none; background: #fff3f0; border: 1px solid #f0c0b0; border-radius: 2px; padding: 16px 20px; color: #a03020; font-size: 13px; line-height: 1.6; margin-bottom: 14px; }
  .error.active { display: block; }

  /* ── Results layout ── */
  .results { display: none; }
  .results.active { display: block; }

  .results-header {
    display: flex; justify-content: space-between; align-items: baseline;
    margin-bottom: 16px; flex-wrap: wrap; gap: 8px;
  }
  .results-title { font-family: 'Playfair Display', serif; font-size: 24px; }
  .results-count { font-family: 'DM Mono', monospace; font-size: 11px; color: var(--terracotta); letter-spacing: 0.1em; }

  /* Source filter tabs */
  .source-tabs { display: flex; gap: 8px; margin-bottom: 16px; flex-wrap: wrap; }
  .source-tab {
    padding: 5px 13px; border: 1.5px solid var(--smoke); border-radius: 2px;
    font-family: 'DM Mono', monospace; font-size: 10px; letter-spacing: 0.1em;
    text-transform: uppercase; cursor: pointer; background: none; color: #8a7060; transition: all 0.15s;
  }
  .source-tab:hover { border-color: var(--terracotta); color: var(--terracotta); }
  .source-tab.active { background: var(--ink); border-color: var(--ink); color: white; }

  /* ── Full-width map above results ── */
  .map-section {
    width: 100%;
    margin-bottom: 28px;
  }

  .map-container {
    width: 100%;
    height: 460px;
    border-radius: 2px;
    border: 1px solid var(--smoke);
    overflow: hidden;
    background: var(--smoke);
  }

  #map { width: 100%; height: 100%; }

  .map-no-key {
    display: flex;
    align-items: center;
    justify-content: center;
    height: 100%;
    font-family: 'DM Mono', monospace;
    font-size: 11px;
    color: #8a7060;
    letter-spacing: 0.08em;
    text-align: center;
    padding: 24px;
    line-height: 1.8;
  }

  /* ── Results body: cards only ── */
  .results-body { display: block; }

  /* ── Cards list ── */
  .card-list { display: flex; flex-direction: column; gap: 12px; }

  /* ── Card ── */
  .card {
    background: var(--cream); border: 1px solid var(--smoke); border-radius: 2px;
    padding: 18px 22px; cursor: pointer;
    display: grid; grid-template-columns: 28px 1fr auto;
    gap: 12px; align-items: start;
    transition: all 0.18s; position: relative; overflow: hidden;
    animation: fadeInUp 0.3s ease both;
  }

  .card::before {
    content: ''; position: absolute; left: 0; top: 0; bottom: 0; width: 3px;
    transform: scaleY(0); transition: transform 0.18s;
  }
  .card.source-places::before { background: var(--places-blue); }
  .card.source-ai::before     { background: var(--terracotta); }

  .card:hover, .card.highlighted {
    box-shadow: 4px 4px 0 rgba(201,81,42,0.14);
    transform: translateX(-2px);
    border-color: rgba(201,81,42,0.3);
  }
  .card:hover::before, .card.highlighted::before { transform: scaleY(1); }

  /* Number badge */
  .card-num {
    width: 24px; height: 24px; border-radius: 50%;
    background: var(--terracotta); color: white;
    font-family: 'DM Mono', monospace; font-size: 10px; font-weight: 500;
    display: flex; align-items: center; justify-content: center;
    flex-shrink: 0; margin-top: 2px;
  }
  .card.source-places .card-num { background: var(--places-blue); }

  .card-name { font-family: 'Playfair Display', serif; font-size: 17px; margin-bottom: 3px; color: var(--ink); }
  .card-address { font-size: 12px; color: #8a7060; margin-bottom: 6px; font-weight: 300; }
  .card-desc { font-size: 12px; line-height: 1.6; color: #4a3828; }

  .card-meta { display: flex; align-items: center; gap: 10px; margin-top: 8px; flex-wrap: wrap; }
  .rating { display: flex; align-items: center; gap: 4px; font-family: 'DM Mono', monospace; font-size: 11px; color: var(--ink); }
  .stars { color: var(--gold); font-size: 10px; }
  .review-count { color: #8a7060; font-size: 10px; }
  .open-badge { font-family: 'DM Mono', monospace; font-size: 9px; letter-spacing: 0.08em; text-transform: uppercase; padding: 2px 7px; border-radius: 2px; }
  .open-badge.open   { background: rgba(42,107,92,0.12); color: var(--accent); }
  .open-badge.closed { background: rgba(201,81,42,0.1);  color: var(--terracotta); }
  .price-level { font-family: 'DM Mono', monospace; font-size: 11px; color: #8a7060; }

  .card-tags { display: flex; gap: 5px; flex-wrap: wrap; margin-top: 8px; }
  .tag { padding: 2px 8px; border-radius: 2px; font-family: 'DM Mono', monospace; font-size: 9px; letter-spacing: 0.08em; text-transform: uppercase; }
  .tag.red   { background: rgba(201,81,42,0.1); color: var(--terracotta); }
  .tag.green { background: rgba(42,107,92,0.1); color: var(--accent); }

  .source-badge { font-family: 'DM Mono', monospace; font-size: 9px; letter-spacing: 0.1em; text-transform: uppercase; padding: 2px 6px; border-radius: 2px; border: 1px solid; }
  .source-badge.places { color: var(--places-blue); border-color: rgba(26,115,232,0.3); background: rgba(26,115,232,0.06); }
  .source-badge.ai     { color: var(--terracotta);  border-color: rgba(201,81,42,0.3);  background: rgba(201,81,42,0.06); }
  .source-badge.review { color: var(--accent);      border-color: rgba(42,107,92,0.3);  background: rgba(42,107,92,0.06); }
  .card.source-review::before   { background: var(--accent); }
  .source-badge.curated { color: var(--gold);        border-color: rgba(212,160,23,0.4);  background: rgba(212,160,23,0.08); }
  .card.source-curated::before  { background: var(--gold); }

  .card-right { display: flex; flex-direction: column; align-items: flex-end; gap: 6px; min-width: 60px; }
  .card-area { font-family: 'DM Mono', monospace; font-size: 9px; letter-spacing: 0.1em; text-transform: uppercase; color: #8a7060; text-align: right; }
  .card-dist { font-family: 'DM Mono', monospace; font-size: 10px; color: var(--accent); font-weight: 500; text-align: right; }
  .maps-link {
    padding: 5px 10px; border: 1.5px solid var(--terracotta); color: var(--terracotta);
    text-decoration: none; border-radius: 2px; font-family: 'DM Mono', monospace;
    font-size: 9px; letter-spacing: 0.08em; text-transform: uppercase;
    transition: all 0.2s; white-space: nowrap;
  }
  .maps-link:hover { background: var(--terracotta); color: white; }

  /* ── Note ── */
  .note {
    text-align: center; font-family: 'DM Mono', monospace; font-size: 10px;
    color: #b09a88; letter-spacing: 0.08em; padding: 24px 0 52px; line-height: 1.8;
  }

  @keyframes fadeInUp {
    from { opacity: 0; transform: translateY(8px); }
    to   { opacity: 1; transform: translateY(0); }
  }

  @media (max-width: 600px) {
    .card { grid-template-columns: 24px 1fr; }
    .card-right { display: none; }
  }
</style>
</head>
<body>
<div class="container">

  <header>
    <h1>Find <em>Gözleme</em><br>Near You</h1>
    <p class="subtitle">Live results from Google Places combined with AI knowledge, mapped across London.</p>
  </header>


    <!-- Search -->
  <div class="search-section">
    <label class="search-label">Search Location</label>
    <div class="search-row">
      <div class="search-input-wrap">
        <input type="text" class="search-input" id="locationInput"
               placeholder="Enter postcode or location here..."
               oninput="toggleClearBtn()">
        <button class="clear-btn" id="clearBtn" onclick="clearSearch()" title="Clear">&#x2715;</button>
      </div>
      <button class="search-btn" id="searchBtn" onclick="searchGozleme()">Search</button>
    </div>
  </div>

  <!-- Loading -->
  <div class="loading" id="loading">
    <div class="spinner"></div>
    <p class="loading-text">Searching for Gözleme spots...</p>
    <div class="loading-steps">
      <span class="loading-step" id="step1">1. Querying Google Places...</span>
      <span class="loading-step" id="step2">2. Asking Claude AI...</span>
      <span class="loading-step" id="step3">3. Geocoding &amp; building map...</span>
    </div>
  </div>

  <!-- Error -->
  <div class="error" id="error"></div>

  <!-- Full-width map — always visible, centred on London by default -->
  <div class="map-section">
    <div class="map-container" id="mapContainer">
      <div class="map-no-key" id="mapNoKey">
        Map will appear here once<br>GOOGLE_MAPS_KEY is set in .env
      </div>
      <div id="map" style="display:none;"></div>
    </div>
  </div>

  <!-- Results -->
  <div class="results" id="results">
    <div class="results-header">
      <h2 class="results-title">Spots Found</h2>
      <span class="results-count" id="resultsCount"></span>
    </div>

    <div class="source-tabs">
      <button class="source-tab active" data-filter="all"    onclick="filterCards(this)">All</button>
      <button class="source-tab"        data-filter="places" onclick="filterCards(this)">Google Places</button>
      <button class="source-tab"        data-filter="ai"     onclick="filterCards(this)">AI Only</button>
      <button class="source-tab"        data-filter="review"   onclick="filterCards(this)">Via Reviews</button>
      <button class="source-tab"        data-filter="curated" onclick="filterCards(this)">⭐ Curated</button>
    </div>

    <div class="results-body">
      <div class="card-list" id="cardContainer"></div>
    </div>
  </div>

  <p class="note">
    Google Places results reflect live business data &middot; AI results are from Claude's training knowledge<br>
    Always call ahead to confirm Gözleme is on the menu
  </p>

</div>

<script>
// ─────────────────────────────────────────────────────────────────────────────
// State
// ─────────────────────────────────────────────────────────────────────────────
var googleMap      = null;
var mapMarkers     = [];
var infoWindow     = null;
var mapsApiLoaded  = false;
var mapsKeyAvailable = false;


// ─────────────────────────────────────────────────────────────────────────────
// Google Maps initialisation
// ─────────────────────────────────────────────────────────────────────────────
async function loadMapsApi() {
  // Ask server for the Maps key
  try {
    var r = await fetch('/api/maps-key');
    if (!r.ok) throw new Error('no key');
    var data = await r.json();
    if (!data.key) throw new Error('empty key');

    mapsKeyAvailable = true;

    // Dynamically inject the Maps JS script
    await new Promise(function(resolve, reject) {
      var s = document.createElement('script');
      s.src = 'https://maps.googleapis.com/maps/api/js?key=' + data.key;
      s.async = true;
      s.onload  = resolve;
      s.onerror = reject;
      document.head.appendChild(s);
    });

    mapsApiLoaded = true;
    document.getElementById('mapNoKey').style.display = 'none';
    document.getElementById('map').style.display = 'block';

    // Initialise map centred on London
    googleMap = new google.maps.Map(document.getElementById('map'), {
      center: { lat: 51.5074, lng: -0.1278 },
      zoom: 11,
      styles: mapStyles(),
      mapTypeControl: false,
      streetViewControl: false,
      fullscreenControl: true,
    });

    infoWindow = new google.maps.InfoWindow();

    // Silently pre-populate the map with London-wide results
    runDefaultSearch();

  } catch(e) {
    // Maps key not configured — map panel stays hidden with the message
    mapsKeyAvailable = false;
  }
}

function mapStyles() {
  return [
    { featureType: 'poi', elementType: 'labels', stylers: [{ visibility: 'off' }] },
    { featureType: 'transit', elementType: 'labels', stylers: [{ visibility: 'off' }] },
    { elementType: 'geometry', stylers: [{ color: '#f5ede0' }] },
    { featureType: 'road', elementType: 'geometry', stylers: [{ color: '#e8ddd0' }] },
    { featureType: 'road.arterial', elementType: 'geometry', stylers: [{ color: '#ddd0c0' }] },
    { featureType: 'water', elementType: 'geometry', stylers: [{ color: '#c8d8e8' }] },
    { elementType: 'labels.text.fill', stylers: [{ color: '#4a3828' }] },
    { elementType: 'labels.text.stroke', stylers: [{ color: '#f5ede0' }] },
  ];
}

// ─────────────────────────────────────────────────────────────────────────────
// Default map population — runs on load, pins London without showing results list
// ─────────────────────────────────────────────────────────────────────────────
async function runDefaultSearch() {
  try {
    var places = await fetchGooglePlaces('gozleme London');
    clearMarkers();
    places.forEach(function(place, i) {
      addMarker(place, i);
    });
    // Don't fit bounds — keep the city-wide view so users can browse
  } catch(e) {
    // Silently fail — user can still search manually
  }
}

// ─────────────────────────────────────────────────────────────────────────────
// Filter tabs
// ─────────────────────────────────────────────────────────────────────────────
function filterCards(btn) {
  document.querySelectorAll('.source-tab').forEach(function(t) { t.classList.remove('active'); });
  btn.classList.add('active');
  var filter = btn.dataset.filter;
  document.querySelectorAll('.card').forEach(function(card) {
    var src = card.dataset.source;
    card.style.display =
      (filter === 'all') ||
      (filter === 'places'  && src === 'places') ||
      (filter === 'ai'      && src === 'ai') ||
      (filter === 'review'  && src === 'review') ||
      (filter === 'curated' && src === 'curated')
        ? '' : 'none';
  });
  // Update map marker visibility to match
  mapMarkers.forEach(function(m) {
    var src = m.placeSource;
    m.setVisible(
      filter === 'all' ||
      (filter === 'places'  && src === 'places') ||
      (filter === 'ai'      && src === 'ai') ||
      (filter === 'review'  && src === 'review') ||
      (filter === 'curated' && src === 'curated')
    );
  });
}

// ─────────────────────────────────────────────────────────────────────────────
// Google Places proxy
// ─────────────────────────────────────────────────────────────────────────────
async function fetchGooglePlaces(query, coords) {
  var lat = (coords && coords.lat) ? coords.lat : 51.5074;
  var lng = (coords && coords.lng) ? coords.lng : -0.1278;
  var resp = await fetch('/api/places', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ textQuery: query, latitude: lat, longitude: lng, radius: 15000, maxResults: 20 })
  });
  var data = await resp.json();
  if (!resp.ok) throw new Error(data.error || 'Google Places proxy error');

  return (data.places || []).map(function(p) {
    return {
      name:        (p.displayName && p.displayName.text) ? p.displayName.text : 'Unknown',
      address:     p.formattedAddress || p.shortFormattedAddress || '',
      area:        extractArea(p.formattedAddress || ''),
      rating:      p.rating || null,
      reviewCount: p.userRatingCount || null,
      isOpen:      (p.currentOpeningHours && p.currentOpeningHours.openNow != null) ? p.currentOpeningHours.openNow : null,
      priceLevel:  p.priceLevel || null,
      mapsUrl:     p.googleMapsUri || null,
      lat:         (p.location && p.location.latitude)  ? p.location.latitude  : null,
      lng:         (p.location && p.location.longitude) ? p.location.longitude : null,
      source:      'places',
      description: '',
      tags:        []
    };
  });
}

// ─────────────────────────────────────────────────────────────────────────────
// Google Places — broad restaurant search filtered by review mentions of gözleme
// ─────────────────────────────────────────────────────────────────────────────
async function fetchPlacesByReview(latitude, longitude) {
  var resp = await fetch('/api/places-by-review', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ latitude: latitude, longitude: longitude, radius: 15000 })
  });
  var data = await resp.json();
  if (!resp.ok) throw new Error(data.error || 'Places-by-review proxy error');

  return (data.places || []).map(function(p) {
    return {
      name:          (p.displayName && p.displayName.text) ? p.displayName.text : 'Unknown',
      address:       p.formattedAddress || p.shortFormattedAddress || '',
      area:          extractArea(p.formattedAddress || ''),
      rating:        p.rating || null,
      reviewCount:   p.userRatingCount || null,
      isOpen:        (p.currentOpeningHours && p.currentOpeningHours.openNow != null) ? p.currentOpeningHours.openNow : null,
      priceLevel:    p.priceLevel || null,
      mapsUrl:       p.googleMapsUri || null,
      lat:           (p.location && p.location.latitude)  ? p.location.latitude  : null,
      lng:           (p.location && p.location.longitude) ? p.location.longitude : null,
      source:        'review',
      description:   p.matchedReview ? 'Mentioned in reviews: "' + p.matchedReview.substring(0, 120).replace(/"/g, "'") + (p.matchedReview.length > 120 ? '...' : '') + '"' : '',
      tags:          ['mentioned in reviews']
    };
  });
}

// ─────────────────────────────────────────────────────────────────────────────
// Curated spots — manually maintained list from curated.json
// ─────────────────────────────────────────────────────────────────────────────
async function fetchCuratedSpots() {
  var resp = await fetch('/api/curated');
  var data = await resp.json();
  if (!resp.ok) throw new Error(data.error || 'Curated spots error');

  return (data.spots || []).map(function(s) {
    return {
      name:        s.name        || 'Unknown',
      address:     s.address     || '',
      area:        s.area        || extractArea(s.address || ''),
      rating:      s.rating      || null,
      reviewCount: s.reviewCount || null,
      isOpen:      s.isOpen      != null ? s.isOpen : null,
      priceLevel:  s.priceLevel  || null,
      mapsUrl:     s.mapsUrl     || null,
      lat:         s.lat         || null,
      lng:         s.lng         || null,
      source:      'curated',
      description: s.description || '',
      tags:        s.tags        || []
    };
  });
}

function extractArea(address) {
  var parts = address.split(',').map(function(s) { return s.trim(); });
  if (parts.length >= 3) return parts[parts.length - 3] || parts[1] || '';
  return parts[1] || '';
}

// ─────────────────────────────────────────────────────────────────────────────
// Geocode proxy (for AI results without coordinates)
// ─────────────────────────────────────────────────────────────────────────────
// Bounding box for Greater London + immediate surrounds
var LONDON_BOUNDS = { minLat: 51.28, maxLat: 51.70, minLng: -0.55, maxLng: 0.35 };

function isInLondon(lat, lng) {
  return lat >= LONDON_BOUNDS.minLat && lat <= LONDON_BOUNDS.maxLat
      && lng >= LONDON_BOUNDS.minLng && lng <= LONDON_BOUNDS.maxLng;
}

async function geocodeAddress(address) {
  try {
    var resp = await fetch('/api/geocode', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ address: address })
    });
    if (!resp.ok) return null;
    var data = await resp.json();
    if (!data.lat || !data.lng) return null;
    // Reject coordinates outside Greater London to prevent restaurant names
    // geocoding to wrong cities or countries
    if (!isInLondon(data.lat, data.lng)) {
      console.warn('Geocode out of London bounds for "' + address + '": ' + data.lat + ', ' + data.lng);
      return null;
    }
    return { lat: data.lat, lng: data.lng };
  } catch(e) {
    return null;
  }
}

// ─────────────────────────────────────────────────────────────────────────────
// AI spots — served from cache.json (built by cache-builder.js).
// Falls back to a live Claude call only if cache is empty or missing.
// ─────────────────────────────────────────────────────────────────────────────
var _cachedSpots = null; // in-memory so we only fetch cache.json once per session

// CACHE_RADIUS_KM — how far from the search centre to include cached spots.
// Matches the 15km radius used by the direct Google Places search.
var CACHE_RADIUS_KM = 5; // ~neighbourhood level — tighter than Google Places to keep results local

async function fetchAiSpots(location, knownNames, searchCoords) {
  // Load cache once per session
  if (_cachedSpots === null) {
    try {
      var cacheResp = await fetch('/api/cached-spots');
      var cacheData = await cacheResp.json();
      _cachedSpots = cacheData.spots || [];
      if (_cachedSpots.length > 0 && cacheData.builtAt) {
        console.log('Cache loaded: ' + _cachedSpots.length + ' spots (built ' + new Date(cacheData.builtAt).toLocaleDateString() + ')');
      }
    } catch(e) {
      _cachedSpots = [];
    }
  }

  if (_cachedSpots.length > 0) {
    var known = new Set(knownNames.map(function(n) { return n.toLowerCase(); }));
    var locLower = location.toLowerCase();
    var isBroadSearch = ['london', 'all', 'everywhere'].some(function(t) { return locLower.includes(t); });

    return _cachedSpots
      .filter(function(s) {
        if (known.has((s.name || '').toLowerCase())) return false;

        // Broad search — return everything in the cache
        if (isBroadSearch) return true;

        // If the spot has coordinates and we have a search centre, filter by radius
        if (searchCoords && s.lat != null && s.lng != null) {
          var dist = haversineKm(searchCoords.lat, searchCoords.lng, s.lat, s.lng);
          return dist <= CACHE_RADIUS_KM;
        }

        // Fall back to string matching for spots without coordinates
        var haystack = ((s.area || '') + ' ' + (s.address || '')).toLowerCase();
        return locLower.split(/\s+/).some(function(word) {
          return word.length > 2 && haystack.includes(word);
        });
      })
      .map(function(s) {
        return Object.assign({}, s, { source: 'ai' });
      });
  }

  // Cache is empty — fall back to live Claude call
  console.log('Cache empty, calling Claude AI live...');
  return fetchClaudeLive(location, knownNames);
}

async function fetchClaudeLive(location, knownNames) {
  var exclusion = knownNames.length > 0
    ? '\n\nDo NOT include these (already found via Google): ' + knownNames.join(', ')
    : '';

  var prompt = 'You are a helpful local food guide for London. Find real eateries in or near "' + location + '" (London, UK) that serve Gozleme (Turkish stuffed flatbread).' + exclusion
    + '\n\nUse only plain ASCII characters in all string values. No apostrophes or special unicode.'
    + '\n\nReturn ONLY a valid JSON array, no markdown. Format:\n[{"name":"...","area":"...","address":"full street address if known","description":"1-2 sentences","tags":["tag1"]}]\n\nUp to 12 results. Only real, confident places.';

  var resp = await fetch('/api/claude', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ model: 'claude-sonnet-4-20250514', max_tokens: 2000, messages: [{ role: 'user', content: prompt }] })
  });

  var data = await resp.json();
  if (!resp.ok) throw new Error('Claude: ' + (data.error && data.error.message ? data.error.message : resp.statusText));

  var allText = (data.content || []).filter(function(b) { return b.type === 'text'; }).map(function(b) { return b.text; }).join('');
  if (!allText) throw new Error('No text response from Claude');

  var jsonText = allText.replace(/```json\s*/gi, '').replace(/```\s*/g, '').trim();
  var arrayMatch = jsonText.match(/\[[\s\S]*\]/);
  if (!arrayMatch) throw new Error('Could not parse Claude response');

  jsonText = arrayMatch[0]
    .replace(/[\u2018\u2019]/g, "'")
    .replace(/[\u201C\u201D]/g, '"')
    .replace(/[\u2013\u2014]/g, '-');

  var places;
  try { places = JSON.parse(jsonText); }
  catch(e) {
    var s = jsonText.replace(/"([^"]*)"/g, function(_, i) { return '"' + i.replace(/[^\x20-\x7E]/g, '') + '"'; });
    places = JSON.parse(s);
  }

  return places.map(function(p) {
    return Object.assign({ rating: null, reviewCount: null, isOpen: null, priceLevel: null, mapsUrl: null, lat: null, lng: null, source: 'ai' }, p);
  });
}

// ─────────────────────────────────────────────────────────────────────────────
// Deduplication
// ─────────────────────────────────────────────────────────────────────────────
function normaliseName(n) { return n.toLowerCase().replace(/[^a-z0-9]/g, ''); }

function isDupe(norm, seen) {
  var dupe = false;
  seen.forEach(function(s) { if (s === norm || s.includes(norm) || norm.includes(s)) dupe = true; });
  return dupe;
}

// Merges three sources: direct Places results take priority, then review-filtered,
// then AI — deduplicating by normalised name throughout
function dedupeAll(placesResults, reviewResults, curatedResults, aiResults) {
  var merged = placesResults.slice();
  var seen = new Set(placesResults.map(function(p) { return normaliseName(p.name); }));

  [reviewResults, curatedResults, aiResults].forEach(function(source) {
    source.forEach(function(p) {
      var norm = normaliseName(p.name);
      if (!isDupe(norm, seen)) { merged.push(p); seen.add(norm); }
    });
  });

  return merged;
}

// ─────────────────────────────────────────────────────────────────────────────
// Map helpers
// ─────────────────────────────────────────────────────────────────────────────
function clearMarkers() {
  mapMarkers.forEach(function(m) { m.setMap(null); });
  mapMarkers = [];
}

function addMarker(place, index) {
  if (!mapsApiLoaded || !googleMap || place.lat == null || place.lng == null) return;

  var colour = place.source === 'places' ? '#1a73e8' : place.source === 'review' ? '#2a6b5c' : place.source === 'curated' ? '#d4a017' : '#c9512a';
  var num      = (index + 1).toString();

  // Custom SVG pin with number
  var svg = '<svg xmlns="http://www.w3.org/2000/svg" width="32" height="40" viewBox="0 0 32 40">'
    + '<path d="M16 0C7.16 0 0 7.16 0 16c0 10 16 24 16 24S32 26 32 16C32 7.16 24.84 0 16 0z" fill="' + colour + '"/>'
    + '<circle cx="16" cy="16" r="10" fill="white" opacity="0.9"/>'
    + '<text x="16" y="20" text-anchor="middle" font-family="DM Mono, monospace" font-size="10" font-weight="bold" fill="' + colour + '">' + num + '</text>'
    + '</svg>';

  var marker = new google.maps.Marker({
    position: { lat: place.lat, lng: place.lng },
    map: googleMap,
    title: place.name,
    icon: {
      url: 'data:image/svg+xml;charset=UTF-8,' + encodeURIComponent(svg),
      scaledSize: new google.maps.Size(32, 40),
      anchor: new google.maps.Point(16, 40),
    },
    zIndex: index,
  });

  marker.placeSource = place.source;
  marker.placeIndex  = index;

  // Click marker → highlight card and open info window
  marker.addListener('click', function() {
    highlightCard(index);
    openInfoWindow(marker, place);
  });

  mapMarkers.push(marker);
  return marker;
}

function openInfoWindow(marker, place) {
  var priceLabel = priceLevelLabel(place.priceLevel);
  var content =
    '<div style="font-family: DM Sans, sans-serif; max-width: 220px; padding: 4px;">' +
      '<strong style="font-family: Playfair Display, serif; font-size: 14px;">' + escHtml(place.name) + '</strong>' +
      (place.address ? '<p style="font-size: 12px; color: #8a7060; margin: 4px 0;">' + escHtml(place.address) + '</p>' : '') +
      (place.rating  ? '<p style="font-size: 12px; margin: 4px 0;">' +
        '<span style="color: #d4a017;">' + starString(place.rating) + '</span> ' + place.rating.toFixed(1) +
        (place.reviewCount ? ' <span style="color: #8a7060;">(' + place.reviewCount.toLocaleString() + ')</span>' : '') +
        (priceLabel ? ' &middot; ' + priceLabel : '') +
        '</p>' : '') +
      (place.isOpen === true  ? '<span style="font-size: 11px; color: #2a6b5c; background: rgba(42,107,92,0.1); padding: 2px 6px; border-radius: 2px;">Open now</span>' : '') +
      (place.isOpen === false ? '<span style="font-size: 11px; color: #c9512a; background: rgba(201,81,42,0.1); padding: 2px 6px; border-radius: 2px;">Closed</span>' : '') +
    '</div>';

  infoWindow.setContent(content);
  infoWindow.open(googleMap, marker);
}

function highlightCard(index) {
  document.querySelectorAll('.card').forEach(function(c) { c.classList.remove('highlighted'); });
  var card = document.querySelector('.card[data-index="' + index + '"]');
  if (card) {
    card.classList.add('highlighted');
    card.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
  }
}

function fitMapToBounds(places, searchCentre) {
  if (!mapsApiLoaded || !googleMap) return;

  // places is already sorted by distance — filter to those with coords
  var mapped = places.filter(function(p) { return p.lat != null && p.lng != null; });
  if (!mapped.length) return;

  // Centre on the nearest result
  var nearest = mapped[0];
  googleMap.setCenter({ lat: nearest.lat, lng: nearest.lng });

  if (mapped.length === 1) {
    googleMap.setZoom(15);
    return;
  }

  // Fit to the closest 5 results with coords
  var nearby = mapped.slice(0, Math.min(5, mapped.length));
  var bounds = new google.maps.LatLngBounds();
  // Include the search centre itself so the map shows where was searched
  if (searchCentre) bounds.extend({ lat: searchCentre.lat, lng: searchCentre.lng });
  nearby.forEach(function(p) { bounds.extend({ lat: p.lat, lng: p.lng }); });
  googleMap.fitBounds(bounds, { top: 60, right: 40, bottom: 40, left: 40 });

  // Clamp zoom: no tighter than z15 (street), no wider than z12 (borough)
  google.maps.event.addListenerOnce(googleMap, 'idle', function() {
    var z = googleMap.getZoom();
    if (z > 15) googleMap.setZoom(15);
    if (z < 12) googleMap.setZoom(12);
  });
}

// ─────────────────────────────────────────────────────────────────────────────
// Helpers
// ─────────────────────────────────────────────────────────────────────────────
function haversineKm(lat1, lng1, lat2, lng2) {
  var R = 6371;
  var dLat = (lat2 - lat1) * Math.PI / 180;
  var dLng = (lng2 - lng1) * Math.PI / 180;
  var a = Math.sin(dLat/2) * Math.sin(dLat/2)
        + Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180)
        * Math.sin(dLng/2) * Math.sin(dLng/2);
  return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
}

function priceLevelLabel(level) {
  return { PRICE_LEVEL_FREE: 'Free', PRICE_LEVEL_INEXPENSIVE: '\u00a3', PRICE_LEVEL_MODERATE: '\u00a3\u00a3', PRICE_LEVEL_EXPENSIVE: '\u00a3\u00a3\u00a3', PRICE_LEVEL_VERY_EXPENSIVE: '\u00a3\u00a3\u00a3\u00a3' }[level] || null;
}

function starString(rating) {
  if (!rating) return '';
  var full = Math.floor(rating);
  var half = (rating - full) >= 0.4 ? 1 : 0;
  return '\u2605'.repeat(full) + (half ? '\u00bd' : '') + '\u2606'.repeat(5 - full - half);
}

function escHtml(str) {
  var d = document.createElement('div');
  d.textContent = String(str);
  return d.innerHTML;
}

function setStep(n) {
  for (var i = 1; i <= 3; i++) {
    var el = document.getElementById('step' + i);
    if (i < n) el.className = 'loading-step done';
    else if (i === n) el.className = 'loading-step active';
    else el.className = 'loading-step';
  }
}

function showError(msg) {
  var error = document.getElementById('error');
  error.classList.add('active');
  error.textContent = msg;
  document.getElementById('loading').classList.remove('active');
  document.getElementById('searchBtn').disabled = false;
}

// ─────────────────────────────────────────────────────────────────────────────
// Main search
// ─────────────────────────────────────────────────────────────────────────────
async function searchGozleme() {
  var location = document.getElementById('locationInput').value.trim();
  if (!location) { showError('Please enter a postcode or location to search.'); return; }

  var btn           = document.getElementById('searchBtn');
  var loading       = document.getElementById('loading');
  var results       = document.getElementById('results');
  var error         = document.getElementById('error');
  var cardContainer = document.getElementById('cardContainer');
  var resultsCount  = document.getElementById('resultsCount');

  btn.disabled = true;
  loading.classList.add('active');
  results.classList.remove('active');
  error.classList.remove('active');
  cardContainer.innerHTML = '';
  clearMarkers();
  setStep(1);

  var placesResults = [], reviewResults = [], curatedResults = [], aiResults = [], errors = [];

  // Step 1a: Geocode the search location first so review search uses precise coords
  var searchCoordsEarly = { lat: 51.5074, lng: -0.1278 }; // fallback: central London
  try {
    var earlyCoords = await geocodeAddress(location);
    if (earlyCoords) searchCoordsEarly = earlyCoords;
    console.log('Search centre: ' + searchCoordsEarly.lat.toFixed(4) + ', ' + searchCoordsEarly.lng.toFixed(4));
  } catch(e) {}

  // Step 1b: Direct gözleme search + searchNearby review-filtered + curated list, in parallel
  try {
    setStep(1);
    var directSearch  = fetchGooglePlaces('gozleme ' + location, searchCoordsEarly);
    var reviewSearch  = fetchPlacesByReview(searchCoordsEarly.lat, searchCoordsEarly.lng);
    var curatedSearch = fetchCuratedSpots();
    var step1Results  = await Promise.allSettled([directSearch, reviewSearch, curatedSearch]);
    placesResults  = step1Results[0].status === 'fulfilled' ? step1Results[0].value : [];
    reviewResults  = step1Results[1].status === 'fulfilled' ? step1Results[1].value : [];
    curatedResults = step1Results[2].status === 'fulfilled' ? step1Results[2].value : [];
    if (step1Results[0].status === 'rejected') errors.push(step1Results[0].reason.message);
    if (step1Results[1].status === 'rejected') errors.push('Review search: ' + step1Results[1].reason.message);
    if (step1Results[2].status === 'rejected') errors.push('Curated: ' + step1Results[2].reason.message);
  } catch(e) { errors.push(e.message); }

  // Step 2: Claude AI
  try {
    setStep(2);
    aiResults = await fetchAiSpots(location, placesResults.map(function(p) { return p.name; }), searchCoordsEarly);
  } catch(e) { errors.push(e.message); }

  // Step 3: Geocode AI results + build map
  setStep(3);

  // Merge all three sources: direct Places, review-filtered Places, AI
  var allPlaces = dedupeAll(placesResults, reviewResults, curatedResults, aiResults);

  // Geocode results that have no coordinates — try address first, fall back to name + area
  if (mapsApiLoaded) {
    var geocodePromises = allPlaces.map(async function(place) {
      if (place.lat != null) return; // already has coords
      var coords = null;
      if (place.address) {
        coords = await geocodeAddress(place.address);
      }
      if (!coords && place.name && place.area) {
        coords = await geocodeAddress(place.name + ', ' + place.area);
      }
      if (!coords && place.name) {
        coords = await geocodeAddress(place.name);
      }
      if (coords) { place.lat = coords.lat; place.lng = coords.lng; }
    });
    await Promise.all(geocodePromises);
  }

  await new Promise(function(r) { setTimeout(r, 200); });

  loading.classList.remove('active');
  btn.disabled = false;

  if (allPlaces.length === 0) {
    showError(errors.length
      ? 'Could not retrieve results. ' + errors.join(' | ')
      : 'No results found near "' + location + '". Try a broader area, a postcode, or just "London".'
    );
    return;
  }

  if (errors.length) {
    error.classList.add('active');
    error.textContent = 'Partial results: ' + errors.join(' | ');
  }

  // Reuse the geocoded coords from step 1a for distance sorting
  var searchCentre = searchCoordsEarly;

  // Attach distance to each place (if we have coords for both)
  allPlaces.forEach(function(place) {
    if (searchCentre && place.lat != null && place.lng != null) {
      place.distance = haversineKm(searchCentre.lat, searchCentre.lng, place.lat, place.lng);
    } else {
      place.distance = null;
    }
  });

  // Sort by distance ascending; places without coords go to the end
  allPlaces.sort(function(a, b) {
    if (a.distance == null && b.distance == null) return 0;
    if (a.distance == null) return 1;
    if (b.distance == null) return -1;
    return a.distance - b.distance;
  });
  if (allPlaces[0] && allPlaces[0].distance != null) {
    console.log('Nearest result: ' + allPlaces[0].name + ' (' + allPlaces[0].distance.toFixed(2) + 'km)');
  }

  results.classList.add('active');

  var placesCount   = allPlaces.filter(function(p) { return p.source === 'places'; }).length;
  var reviewCount   = allPlaces.filter(function(p) { return p.source === 'review'; }).length;
  var curatedCount  = allPlaces.filter(function(p) { return p.source === 'curated'; }).length;
  var aiCount       = allPlaces.filter(function(p) { return p.source === 'ai'; }).length;
  var parts = [];
  if (placesCount)  parts.push(placesCount + ' direct');
  if (reviewCount)  parts.push(reviewCount + ' via reviews');
  if (curatedCount) parts.push(curatedCount + ' curated');
  if (aiCount)      parts.push(aiCount + ' from AI');
  resultsCount.textContent = allPlaces.length + ' spot' + (allPlaces.length !== 1 ? 's' : '') + ' \u00b7 ' + parts.join(', ');

  // Render cards + markers
  allPlaces.forEach(function(place, i) {
    // Card
    var card = document.createElement('div');
    card.className = 'card source-' + place.source;
    card.dataset.source = place.source;
    card.dataset.index  = i;
    card.style.animationDelay = (i * 0.04) + 's';

    var mapsUrl = place.mapsUrl ||
      'https://www.google.com/maps/search/' + encodeURIComponent((place.name || '') + ' ' + (place.address || '') + ' London');

    var metaHtml = '';
    if (place.rating) {
      metaHtml += '<span class="rating"><span class="stars">' + starString(place.rating) + '</span> ' + place.rating.toFixed(1);
      if (place.reviewCount) metaHtml += ' <span class="review-count">(' + place.reviewCount.toLocaleString() + ')</span>';
      metaHtml += '</span>';
    }
    if (place.isOpen === true)  metaHtml += '<span class="open-badge open">Open now</span>';
    if (place.isOpen === false) metaHtml += '<span class="open-badge closed">Closed</span>';
    var priceLabel = priceLevelLabel(place.priceLevel);
    if (priceLabel) metaHtml += '<span class="price-level">' + priceLabel + '</span>';

    var sourceLabel = place.source === 'places' ? 'Google Places' : place.source === 'review' ? 'Via Reviews' : place.source === 'curated' ? '⭐ Curated' : 'Claude AI';
    var sourceBadge = '<span class="source-badge ' + place.source + '">' + sourceLabel + '</span>';
    var tags = (place.tags || []).map(function(t, idx) {
      return '<span class="tag ' + (idx % 2 === 0 ? 'red' : 'green') + '">' + escHtml(t) + '</span>';
    }).join('');

    card.innerHTML =
      '<div class="card-num">' + (i + 1) + '</div>' +
      '<div class="card-left">' +
        '<h3 class="card-name">' + escHtml(place.name || 'Unknown') + '</h3>' +
        '<p class="card-address">&#128205; ' + escHtml(place.address || place.area || 'London') + '</p>' +
        (place.description ? '<p class="card-desc">' + escHtml(place.description) + '</p>' : '') +
        (metaHtml ? '<div class="card-meta">' + metaHtml + '</div>' : '') +
        '<div class="card-tags">' + sourceBadge + tags + '</div>' +
      '</div>' +
      '<div class="card-right">' +
        (place.distance != null ? '<span class="card-dist">' + (place.distance < 1 ? Math.round(place.distance * 1000) + 'm' : place.distance.toFixed(1) + 'km') + '</span>' : '<span class="card-area">' + escHtml(place.area || '') + '</span>') +
        '<a href="' + mapsUrl + '" target="_blank" rel="noopener" class="maps-link" onclick="event.stopPropagation()">Map &#8594;</a>' +
      '</div>';

    // Click card → pan map to marker
    (function(placeRef, idx) {
      card.addEventListener('click', function() {
        if (mapsApiLoaded && googleMap && mapMarkers[idx]) {
          googleMap.panTo(mapMarkers[idx].getPosition());
          googleMap.setZoom(15);
          openInfoWindow(mapMarkers[idx], placeRef);
          highlightCard(idx);
        }
      });
    })(place, i);

    cardContainer.appendChild(card);

    // Map marker
    addMarker(place, i);
  });

  // Fit map to all markers
  fitMapToBounds(allPlaces, searchCentre);
}

// ─────────────────────────────────────────────────────────────────────────────
// Init
// ─────────────────────────────────────────────────────────────────────────────
function toggleClearBtn() {
  var val = document.getElementById('locationInput').value;
  var btn = document.getElementById('clearBtn');
  if (val.length > 0) btn.classList.add('visible');
  else btn.classList.remove('visible');
}

function clearSearch() {
  document.getElementById('locationInput').value = '';
  document.getElementById('clearBtn').classList.remove('visible');
  document.getElementById('locationInput').focus();
}

document.getElementById('locationInput').addEventListener('keydown', function(e) {
  if (e.key === 'Enter') searchGozleme();
});

// Load Maps API in the background immediately
loadMapsApi();
</script>
</body>
</html>
